<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Выбрать эффект</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #ffffff;
      --text: #171717;
      --muted: #737373;
      --border: #e5e5e5;
      --card-bg: rgba(255, 255, 255, 0.8);
      --success: #00aa66;
      --input-bg: #f5f5f5;
    }
    @media (prefers-color-scheme: dark) {
      :root {
        --bg: #0a0a0a;
        --text: #ededed;
        --muted: #a1a1a1;
        --border: #262626;
        --card-bg: rgba(20, 20, 20, 0.8);
        --success: #44cc99;
        --input-bg: #1a1a1a;
      }
    }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Inter', sans-serif;
      background-color: var(--bg);
      color: var(--text);
      padding: 40px 20px;
      min-height: 100vh;
      overflow-x: hidden;
      position: relative;
    }
    canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1;
    }
    .content-wrapper {
      position: relative;
      z-index: 10;
      max-width: 1200px;
      margin: 0 auto;
    }
    .header {
      text-align: center;
      margin-bottom: 40px;
    }
    h1 {
      font-weight: 300;
      font-size: 2.5rem;
      margin-bottom: 20px;
    }
    .controls {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin-bottom: 40px;
      flex-wrap: wrap;
    }
    input[type="text"] {
      padding: 12px 20px;
      border-radius: 12px;
      border: 1px solid(var(--border));
      background: var(--input-bg);
      color: var(--text);
      font-size: 1rem;
      width: 100%;
      max-width: 400px;
      outline: none;
      transition: all 0.2s;
    }
    input[type="text"]:focus {
      border-color: var(--text);
      box-shadow: 0 0 0 2px rgba(100,100,100,0.1);
    }

    .help {
      max-width: 820px;
      margin: 0 auto 24px;
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 14px 16px;
      color: var(--muted);
      font-size: 0.9rem;
      line-height: 1.5;
    }
    .help b { color: var(--text); font-weight: 500; }
    .help code {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      background: var(--input-bg);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 2px 6px;
      color: var(--text);
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 20px;
    }

    .effect-card {
      background: var(--card-bg);
      border: 1px solid(var(--border));
      border-radius: 16px;
      padding: 16px;
      cursor: pointer;
      position: relative;
      transition: all 0.2s;
      overflow: hidden;
    }
    .effect-card:hover {
      transform: translateY(-4px);
      border-color: var(--text);
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }
    .effect-card.active {
      border-color: var(--success);
      box-shadow: 0 0 0 2px var(--success);
    }

    .preview-area {
      height: 120px;
      background: var(--input-bg);
      border-radius: 8px;
      margin-bottom: 12px;
      position: relative;
      overflow: hidden;
    }
    .effect-name {
      font-weight: 500;
      font-size: 0.9rem;
      margin-bottom: 4px;
    }
    .effect-tags {
      font-size: 0.75rem;
      color: var(--muted);
      text-transform: lowercase;
    }
    .copy-btn {
      margin-top: 8px;
      padding: 4px 8px;
      font-size: 0.8rem;
      background: var(--text);
      color: var(--bg);
      border: none;
      border-radius: 4px;
      cursor: pointer;
      width: 100%;
    }
    .copy-btn:hover {
      opacity: 0.9;
    }

    .back {
      display: inline-block;
      margin-top: 40px;
      color: var(--muted);
      text-decoration: none;
      font-size: 0.9rem;
    }
    .back:hover { color: var(--text); }

    .load-more {
      display: block;
      margin: 40px auto;
      padding: 12px 30px;
      background: var(--text);
      color: var(--bg);
      border: none;
      border-radius: 20px;
      cursor: pointer;
      font-size: 1rem;
    }

    .toast {
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%) translateY(100px);
      background: var(--text);
      color: var(--bg);
      padding: 12px 24px;
      border-radius: 30px;
      font-size: 0.9rem;
      opacity: 0;
      transition: all 0.3s;
      z-index: 1000;
    }
    .toast.show {
      transform: translateX(-50%) translateY(0);
      opacity: 1;
    }

    .footer {
      position: absolute;
      bottom: 0;
      width: 100%;
      padding: 20px;
      font-size: 0.8rem;
      color: var(--muted);
      text-align: center;
      background: var(--bg);
      border-top: 1px solid(var(--border));
      z-index: 5;
    }
  </style>
</head>
<body>

  <canvas id="grid-canvas"></canvas>

  <div class="content-wrapper">
    <div class="header">
      <h1>Библиотека эффектов</h1>
      <div class="controls">
        <input type="text" id="search" placeholder="Поиск по названию, цвету, форме...">
      </div>
    </div>

    <div class="help">
      <b>Как сохранить эффект:</b> кликните по карточке эффекта — она подсветится (значит выбран).<br>
      <b>Как вставить в расширение:</b> нажмите <code>Копировать название</code>, откройте расширение и вставьте название в поле, затем нажмите <b>Активировать</b>.
    </div>

    <div class="grid" id="grid"></div>
    <button class="load-more" id="load-more">Показать еще</button>

    <div style="text-align: center;">
      <a href="index.html" class="back">← Вернуться на главную</a>
    </div>
  </div>
  <br><br><br>
  <div class="footer">
    <p style="margin-left: -2%; opacity: 0.5;">&copy; Поддержать автора <a href="#" style="color: #00aa66;">сдесь</a></p>
  </div>

  <div class="toast" id="toast">Эффект применен!</div>

  <script>
    const gridCanvas = document.getElementById('grid-canvas');
    const gCtx = gridCanvas.getContext('2d');
    let points = [];
    const mouse = { x: -2000, y: -2000 };
    const spacing = 70;
    const radius = 130;
    const spring = 0.07;
    const friction = 0.89;

    function initGrid() {
      gridCanvas.width = window.innerWidth;
      gridCanvas.height = window.innerHeight;
      points = [];
      for (let x = 0; x <= gridCanvas.width + spacing; x += spacing) {
        for (let y = 0; y <= gridCanvas.height + spacing; y += spacing) {
          points.push({ x, y, ox: x, oy: y, vx: 0, vy: 0 });
        }
      }
    }

    function animateGrid() {
      gCtx.clearRect(0, 0, gridCanvas.width, gridCanvas.height);
      const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
      gCtx.strokeStyle = isDark ? 'rgba(255,255,255,0.07)' : 'rgba(0,0,0,0.07)';
      gCtx.lineWidth = 1.3;

      points.forEach(p => {
        const dx = mouse.x - p.x;
        const dy = mouse.y - p.y;
        const dist = Math.sqrt(dx*dx + dy*dy);

        if (dist < radius) {
          const force = (radius - dist) / radius;
          p.vx -= (dx / dist) * force * 9;
          p.vy -= (dy / dist) * force * 9;
        }

        p.vx += (p.ox - p.x) * spring;
        p.vy += (p.oy - p.y) * spring;
        p.vx *= friction;
        p.vy *= friction;
        p.x += p.vx;
        p.y += p.vy;

        gCtx.beginPath();
        gCtx.arc(p.x, p.y, 1.1, 0, Math.PI * 2);
        gCtx.stroke();
      });
      requestAnimationFrame(animateGrid);
    }

    window.addEventListener('mousemove', e => {
      mouse.x = e.clientX;
      mouse.y = e.clientY;
    });

    window.addEventListener('resize', initGrid);
    initGrid();
    animateGrid();
  </script>

  <!-- ГЕНЕРАТОР ЭФФЕКТОВ -->
  <script>
    const colors = [
      { name: 'Red', val: ['#ff4d4d', '#ff0000'] },
      { name: 'Orange', val: ['#ff9f43', '#ff6b6b'] },
      { name: 'Yellow', val: ['#feca57', '#ff9f43'] },
      { name: 'Green', val: ['#1dd1a1', '#10ac84'] },
      { name: 'Cyan', val: ['#00d2d3', '#01a3a4'] },
      { name: 'Blue', val: ['#54a0ff', '#2e86de'] },
      { name: 'Purple', val: ['#5f27cd', '#341f97'] },
      { name: 'Pink', val: ['#ff9ff3', '#f368e0'] },
      { name: 'White', val: ['#ffffff', '#c8d6e5'] },
      { name: 'Dark', val: ['#576574', '#222f3e'] },
      { name: 'Neon', val: ['#00ff00', '#ff00ff'] },
      { name: 'Gold', val: ['#ffd700', '#ffa500'] },
    ];

    const shapes = [
      { name: 'Circle', type: 'circle' },
      { name: 'Square', type: 'square' },
      { name: 'Triangle', type: 'triangle' },
      { name: 'Star', type: 'star' },
      { name: 'Heart', type: 'heart' },
    ];

    const behaviors = [
      { name: 'Gravity', config: { gravity: 0.15, vy: -3, friction: 0.99 } },
      { name: 'Float', config: { gravity: -0.05, vy: 1, friction: 0.98 } },
      { name: 'Explode', config: { gravity: 0.05, speed: 8, friction: 0.92 } },
      { name: 'Swarm', config: { gravity: 0, speed: 2, friction: 1, wander: 0.5 } },
    ];

    let allEffects = [];

    const specials = [
      { id: 'confetti', name: 'Party Confetti', colors: ['#ff0000', '#00ff00', '#0000ff', '#ffff00'], shape: 'square', config: { gravity: 0.1, spread: 1, speed: 5, size: {min:4, max:8} }, tags: 'party fun' },
      { id: 'fireworks', name: 'Fireworks', colors: ['#ff0000', '#ffd700'], shape: 'circle', config: { gravity: 0.05, composite: 'lighter', count: 30, speed: 10, decay: 0.03 }, tags: 'bright light' },
      { id: 'matrix', name: 'Matrix Code', colors: ['#00ff00'], shape: 'text', text: '01', config: { gravity: 0.2, speed: 0, spread: 0.1 }, tags: 'hacker digital' },
      { id: 'snow', name: 'Soft Snow', colors: ['#ffffff'], shape: 'circle', config: { gravity: 0.02, speed: 1, friction: 0.99, size: {min:2, max:4} }, tags: 'winter cold' },
    ];

    allEffects.push(...specials);

    let idCounter = 1;
    behaviors.forEach(beh => {
      shapes.forEach(shape => {
        colors.forEach(col => {
          allEffects.push({
            id: `gen_${idCounter++}`,
            name: `${col.name} ${shape.name} ${beh.name}`,
            colors: col.val,
            shape: shape.type,
            config: { ...beh.config },
            tags: `${col.name} ${shape.name} ${beh.name} generated`.toLowerCase()
          });
        });
      });
    });

    const grid = document.getElementById('grid');
    const searchInput = document.getElementById('search');
    const loadMoreBtn = document.getElementById('load-more');
    const toast = document.getElementById('toast');

    let visibleCount = 20;
    let filteredEffects = [...allEffects];
    let currentCleanup = null;

    function render() {
      grid.innerHTML = '';
      const activeName = localStorage.getItem('ce_active_name') || '';

      const toShow = filteredEffects.slice(0, visibleCount);

      toShow.forEach(eff => {
        const el = document.createElement('div');
        el.className = `effect-card ${activeName === eff.name ? 'active' : ''}`;
        el.onclick = () => selectEffect(eff, el);

        el.innerHTML = `
          <div class="preview-area" id="preview-${eff.id}"></div>
          <div class="effect-name">${eff.name}</div>
          <div class="effect-tags">${eff.tags.split(' ').slice(0,3).join(', ')}</div>
          <button class="copy-btn">Копировать название</button>
        `;

        el.querySelector('.copy-btn').addEventListener('click', (e) => {
          e.stopPropagation();
          navigator.clipboard.writeText(eff.name).then(() => {
            toast.textContent = 'Название скопировано!';
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 2000);
          }).catch(() => {
            toast.textContent = 'Ошибка копирования';
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 2000);
          });
        });

        el.onmouseenter = () => startPreview(eff, el.querySelector('.preview-area'));
        el.onmouseleave = () => stopPreview();

        grid.appendChild(el);
      });

      if (visibleCount >= filteredEffects.length) {
        loadMoreBtn.style.display = 'none';
      } else {
        loadMoreBtn.style.display = 'block';
      }
    }

    searchInput.addEventListener('input', (e) => {
      const term = e.target.value.toLowerCase();
      filteredEffects = allEffects.filter(eff =>
        eff.name.toLowerCase().includes(term) ||
        eff.tags.includes(term)
      );
      visibleCount = 20;
      render();
    });

    loadMoreBtn.addEventListener('click', () => {
      visibleCount += 20;
      render();
    });

    function selectEffect(eff, el) {
      document.querySelectorAll('.effect-card').forEach(c => c.classList.remove('active'));
      el.classList.add('active');

      localStorage.setItem('ce_active_name', eff.name);

      toast.textContent = 'Эффект сохранён!';
      toast.classList.add('show');
      setTimeout(() => toast.classList.remove('show'), 2000);
    }

    let animationFrame;

    function startPreview(effect, container) {
      stopPreview();

      const canvas = document.createElement('canvas');
      canvas.width = container.offsetWidth;
      canvas.height = container.offsetHeight;
      container.appendChild(canvas);
      const ctx = canvas.getContext('2d');

      let particles = [];
      const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;

      function getBrightness(hex) {
        if (!hex || hex.length < 7) return 0;
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return (r * 299 + g * 587 + b * 114) / 1000;
      }

      let finalColors = effect.colors || (isDark ? ['#ffffff'] : ['#000000']);
      if (isDark && finalColors.every(c => getBrightness(c) < 128)) finalColors = ['#ffffff'];
      if (!isDark && finalColors.every(c => getBrightness(c) >= 128)) finalColors = ['#000000'];

      const spawnInterval = setInterval(() => {
        if(particles.length > 30) return;
        spawn(canvas.width/2, canvas.height/2);
      }, 100);

      function spawn(x, y) {
        const count = effect.config.count || 8;
        for(let i=0; i<count; i++) {
          const angle = Math.random() * Math.PI * 2;
          const speed = (Math.random() * (effect.config.speed || 5)) + 1;
          
          particles.push({
            x: x,
            y: y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 1.0,
            decay: effect.config.decay || 0.02,
            friction: effect.config.friction || 0.99,
            size: (effect.config.size && effect.config.size.min) ?
                  (Math.random() * (effect.config.size.max - effect.config.size.min) + effect.config.size.min) :
                  (Math.random() * 3 + 2),
            color: finalColors[Math.floor(Math.random() * finalColors.length)],
            gravity: effect.config.gravity !== undefined ? effect.config.gravity : 0.15,
            shape: effect.shape || 'circle',
            text: effect.text || '01'
          });
        }
      }

      function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        ctx.fillStyle = 'rgba(100,100,100,0.1)';
        ctx.fillRect(0,0,canvas.width, canvas.height);

        for (let i = particles.length - 1; i >= 0; i--) {
          const p = particles[i];
          p.x += p.vx;
          p.y += p.vy;
          p.vy += p.gravity;
          p.vx *= p.friction;
          p.vy *= p.friction;
          p.life -= p.decay;

          if (p.life <= 0) {
            particles.splice(i, 1);
            continue;
          }

          ctx.globalAlpha = p.life;
          ctx.fillStyle = p.color;
          ctx.beginPath();

          if (p.shape === 'square') {
            ctx.rect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);
          } else if (p.shape === 'triangle') {
            ctx.moveTo(p.x, p.y - p.size);
            ctx.lineTo(p.x + p.size, p.y + p.size);
            ctx.lineTo(p.x - p.size, p.y + p.size);
            ctx.closePath();
          } else if (p.shape === 'star') {
            const spikes = 5;
            const outerRadius = p.size;
            const innerRadius = p.size / 2;
            let rot = Math.PI / 2 * 3;
            ctx.moveTo(p.x, p.y - outerRadius);
            for (let j = 0; j < spikes; j++) {
              const x1 = p.x + Math.cos(rot) * outerRadius;
              const y1 = p.y + Math.sin(rot) * outerRadius;
              ctx.lineTo(x1, y1);
              rot += Math.PI / spikes;
              const x2 = p.x + Math.cos(rot) * innerRadius;
              const y2 = p.y + Math.sin(rot) * innerRadius;
              ctx.lineTo(x2, y2);
              rot += Math.PI / spikes;
            }
            ctx.lineTo(p.x, p.y - outerRadius);
            ctx.closePath();
          } else if (p.shape === 'text') {
            ctx.font = `${p.size * 4}px monospace`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(p.text, p.x, p.y);
          } else {
            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
          }
          ctx.fill();
        }
        animationFrame = requestAnimationFrame(animate);
      }

      animate();

      currentCleanup = () => {
        clearInterval(spawnInterval);
        cancelAnimationFrame(animationFrame);
        if(canvas.parentNode) canvas.parentNode.removeChild(canvas);
      };
    }

    function stopPreview() {
      if (currentCleanup) {
        currentCleanup();
        currentCleanup = null;
      }
    }

    render();
  </script>
</body>
</html>